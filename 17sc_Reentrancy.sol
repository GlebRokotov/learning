// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract ReentrancyAuction {
    mapping(address => uint) public bidders;                               // объявляет публичное отображение (mapping) bidders, которое связывает
                                                                           // адреса участников аукциона с их суммами ставок.

    bool locked;                                                           // значение по умолчанию для bool в Solidity — false

    function bid() external payable {
        bidders[msg.sender] += msg.value;                                  // msg.sender адрес того, кто вызвал функцию bid(). Происходит обращение
                                                                           // к (mapping) bidders, которое связывает адреса участников аукциона с
                                                                           // их суммами ставок. Если msg.sender уже делал ставки ранее, то
                                                                           // bidders[msg.sender] вернет сумму всех его предыдущих ставок. Далее
                                                                           // используется оператор присваивания с добавлением (+=), он работает
                                                                           // следующим образом: сначала берется текущее значение 
                                                                           // bidders[msg.sender] (сумма всех предыдущих ставок отправителя). К
                                                                           // этому значению добавляется msg.value (сумма, отправленная в текущей
                                                                           // транзакции)
    }

    modifier noReentrancy() {                                              // порядок работы функции refund() с модификатором noReentrancy при
                                                                           // атаке: 1.атакующий вызывает функцию refund 2.модификатор noReentrancy
                                                                           // проверяет, что locked равно false, и устанавливает locked = true.
                                                                           // 3.контракт проверяет, что у атакующего есть средства для возврата
                                                                           // (refundAmount > 0). 4.контракт обнуляет баланс атакующего
                                                                           // (bidders[msg.sender] = 0). 5.контракт отправляет эфир атакующему
                                                                           // через msg.sender.call 6.если атакующий является контрактом, то
                                                                           // при получении эфира автоматически вызывается его функция receive.
                                                                           // 7.в функции receive атакующий пытается снова вызвать refund. 
                                                                           // 8.модификатор noReentrancy проверяет, что locked равно true, и
                                                                           // отклоняет вызов с сообщением "no reentrancy!". 9.выполнение функции
                                                                           // refund завершается, и locked снова устанавливается в false. 
                                                                           // Результат: рекурсия прерывается на шаге 8, так как повторный вызов
                                                                           // refund отклоняется.
        require(!locked, "no reentrancy!");
        locked = true;
        _;
        locked = false;
    }
    
    function refund() external noReentrancy {
        uint refundAmount = bidders[msg.sender];
        bidders[msg.sender] = 0;
        if (refundAmount > 0) {
            (bool success,) = msg.sender.call{value: refundAmount, gas: 3_000_000}("");
            require(success, "failed!");
        }
    }
    /*
        Разбор работы refund() при различных сценариях кода. Если не добавлять защиту с помощью обнуления баланса sender до отправки эфира и защиту
    с помощью модификатора, то атака очевидно проходит. 
        В случае когда мы добавляем bidders[msg.sender] = 0; после отправки эфира для зануления баланса участника аукциона, то атака снова
    проходит, поскольку с помощью функция receive() в атакующем контракте рекурсивно вызывает refund() во время отправки эфира на баланс
    атакующего.

        В случае при котором баланс атакующего зануляется до отправки эфира, предварительно сохраняя это значение в «буферную» переменную мы
    отправляем атакующему обратно его ставку, но отражаем его атаку. Это происходит так: обнуляем баланс атакующего -> отправляем ему средства ->
    с помощью функции receive() вновь вызываем refund (), но баланс уже 0 и условие отправки refundAmount>0 не срабатывает из-за нулевого баланса
    атакующего, дальше в call не проходим и завершаем итерацию вызванную рекурсией -> возвращаемся родительскую итерацию и успешно ей завершаем.
    Таким образом рекурсия завершается естественным образом, потому что переменная bidders[msg.sender] была обнулена до вызова call.

    В случае с добавлением модификатора noReentrancy мы получим результат, при котором транзакция вылетает с ошибкой из
    require(success, "failed!"); , а транзакция откатится. обнуляем баланс атакующего -> отправляем ему средства -> с помощью функции receive()
    вновь вызываем refund (), но уже не попадаем в него по причине защиты модификатора. Вываливается ошибка  из функции refund()
    require(success, "failed!"); ,  а не ошибка в модификаторе require(!locked, "no reentrancy!"); атакующий контракт не смог получить эфир,
    потому что во время его обработки произошла ошибка в refund(), связанная с модификатором noReentrancy. Когда атакующий контракт получает эфир, 
    автоматически вызывается его receive(), который снова вызывает auction.refund(). Однако из-за модификатора повторный вызов refund() запрещён 
    (защита от повторного входа), и выполнение прерывается с ошибкой "no reentrancy!". Поскольку этот вызов refund() был сделан через call,
    Solidity не выбрасывает ошибку напрямую, а просто возвращает false в переменную success. Затем первая итерация refund() проверяет
    require(success, "failed!");, видит, что success == false, и выбрасывает "failed!", что приводит к откату всей транзакции. Ошибки, которые
    возникают в call и delegatecall не вываливаются в консоль, а перехватываются и возвращают false, но не откатывают транзакцию автоматически.
    */

    function currentBalance() external view returns(uint) {
        return address(this).balance;
    }
}

contract ReentrancyAttack {                                                  // ReentrancyAttack, который будет использоваться для атаки на
                                                                             // ReentrancyAuction 
    uint constant BID_AMOUNT = 1 ether;
    ReentrancyAuction auction;

    

    constructor(address _auction) {
        auction = ReentrancyAuction(_auction);                               // принимает адрес контракта ReentrancyAuction и сохраняет его в
                                                                             // переменной auction.
    }

    function proxyBid() external payable {                                   // атакующий контракт ReentrancyAttack делает ставку через proxyBid()
        require(msg.value == BID_AMOUNT, "incorrect");
        auction.bid{value: msg.value}();
    }

    function attack() external {                                             // затем атакующий вызывает attack, который инициирует возврат
                                                                             // средств через refund(). внутри функции refund() происходит отправка
                                                                             // эфира на адрес атакующего контракта.
       auction.refund();
    }

    receive() external payable {                                             // когда атакующий контракт получает эфир, автоматически вызывается
                                                                             // функция receive, которая снова вызывает refund, пока баланс
                                                                             // контракта ReentrancyAuction не станет меньше BID_AMOUNT. в
                                                                             // противном случае произойдёт бесконечная рекурсия. без этого условия
                                                                             // даже после обнуления баланса контракта функция receive() продолжала
                                                                             // бы вызываться снова и снова, вызывая ошибку. С условием же рекурсия
                                                                             // ограничивается только в тех случаях, когда у контракта достаточно
                                                                             // средств.
        if(auction.currentBalance() >= BID_AMOUNT) {
            auction.refund();
        }
        
    }

    function currentBalance() external view returns(uint) {
        return address(this).balance;
    }
}